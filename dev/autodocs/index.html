<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · WaveguideModes</title><meta name="title" content="API Reference · WaveguideModes"/><meta property="og:title" content="API Reference · WaveguideModes"/><meta property="twitter:title" content="API Reference · WaveguideModes"/><meta name="description" content="Documentation for WaveguideModes."/><meta property="og:description" content="Documentation for WaveguideModes."/><meta property="twitter:description" content="Documentation for WaveguideModes."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../Contents/">WaveguideModes</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../Contents/">Contents</a></li><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../Tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Publicly-Exported-Functions"><span>Publicly Exported Functions</span></a></li><li><a class="tocitem" href="#Publicly-Exported-Types"><span>Publicly Exported Types</span></a></li><li class="toplevel"><a class="tocitem" href="#Non-Exported-API-(Subject-to-Change)"><span>Non-Exported API (Subject to Change)</span></a></li><li><a class="tocitem" href="#Private-Functions"><span>Private Functions</span></a></li><li><a class="tocitem" href="#Private-Types"><span>Private Types</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com/simonp0420/WaveguideModes.jl.git" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Reference"><a class="docs-heading-anchor" href="#Public-API-Reference">Public API Reference</a><a id="Public-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Reference" title="Permalink"></a></h1><h2 id="Publicly-Exported-Functions"><a class="docs-heading-anchor" href="#Publicly-Exported-Functions">Publicly Exported Functions</a><a id="Publicly-Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Publicly-Exported-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.lookup_rwg" href="#WaveguideModes.lookup_rwg"><code>WaveguideModes.lookup_rwg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lookup_rwg(wgspec::AbstractString) -&gt; (a, b)</code></pre><p>Find the dimensions of a rectangular waveguide given its &quot;spec&quot; (a string using standard waveguide nomenclature).</p><p><strong>Input Argument</strong></p><ul><li><code>wgspec::AbstractString</code>: A standard (EIA, RCSC, or IEC) abbreviation for a rectangular waveguide size. Examples include <code>&quot;WR650&quot;</code> (EIA), <code>&quot;WG7&quot;</code> (RCSC), and <code>&quot;R22&quot;</code> (IEC).</li></ul><p><strong>Return Value</strong></p><ul><li><code>(a, b)</code>: Waveguide inner dimensions in the x and y directions, respectively, expressed as <code>Unitful</code> quantities with units of <code>u&quot;inch&quot;</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.rwg_modes" href="#WaveguideModes.rwg_modes"><code>WaveguideModes.rwg_modes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rwg_modes(a, b, f; nmodes=10, ϵᵣ=1.0, tanδ=0.0, σ=Inf*u&quot;S/m&quot;, Rq=0.0u&quot;m&quot;) -&gt; modedata</code></pre><p>Compute cutoff frequency, guide wavelength, and attenuation constant for first few modes of a rectangular waveguide.</p><p>Note: This function is intended for programmatic use.  For interactive use, see <code>rwg_modetable</code>.  </p><p><strong>Required Positional Arguments</strong></p><ul><li><code>a</code>, <code>b</code>: The waveguide inner dimensions as any <code>Unitful</code> length quantity, e.g. <code>b=0.8128u&quot;cm&quot;</code>, <code>b=320u&quot;mil&quot;</code>,  or <code>b=0.320u&quot;inch&quot;</code>.  <code>a</code> and <code>b</code> must be expressed in the same length units.</li><li><code>f</code>: The frequency as any <code>Unitful</code> frequency quantity, e.g. <code>f=3u&quot;GHz&quot;</code>,  <code>f=3e9u&quot;Hz&quot;</code> or <code>f=3000u&quot;MHz&quot;</code>.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>nmodes</code>: The number of modes to be treated.  Defaults to <code>10</code>.</li><li><code>ϵᵣ</code> or <code>epsr</code>: The dielectric constant for the material filling the waveguide.</li><li><code>tanδ</code> or <code>tandel</code>: The loss tangent for the dielectric material filling the waveguide.</li><li><code>σ</code> or <code>sigma</code>: Bulk conductivity of the metal walls in any <code>Unitful</code> quantity with dimensions equal to those of <code>u&quot;S/m&quot;</code>. Defaults to <code>Inf*u&quot;S/m&quot;</code> (perfect electric conductor).</li><li><code>Rq</code>: Surface RMS roughness of the metal walls in any <code>Unitful</code> length dimension, e.g. <code>6u&quot;μm&quot;</code>. Defaults to <code>0u&quot;m&quot;</code> (perfectly smooth).  The surface roughness is used with <code>σ</code> to compute a (lower) effective  conductivity via the <a href="https://github.com/simonp0420/MetalSurfaceImpedance.jl"><code>MetalSurfaceImpedance</code></a> package.</li></ul><p><strong>Return Value</strong></p><ul><li><code>modedata::Matrix{Any}</code>: A matrix of size <code>(nmodes, 6)</code>, containing in each row <code>[p, m, n, fco, λg, α]</code> for a single mode. Here <code>p = &quot;TE&quot;</code> for a TE mode or <code>&quot;TM&quot;</code> for a TM mode, <code>m</code> and <code>n</code> are integer mode indices in the x and y directions, resp., <code>fco</code> is the cutoff frequency expressed in the same units as input argument <code>f</code> (but without attached units), <code>λg</code> is the guide wavelength expressed in the same  units as <code>a</code> and <code>b</code> (but without attached units), and <code>α</code> is the mode attenuation constant in units  of dB/unitlength (without attached units), where unitlength is one unit of length in the same units  as <code>a</code> and <code>b</code>. The modes are listed in order of increasing cutoff frequency. For cutoff modes (other than TEₘ₀ or TE₀ₙ which are calculated more accurately when wall losses are present) the value of  <code>λg</code> will be <code>Inf</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><div class="admonition is-warning" id="Missing-docstring.-fd4bf14720dcaf8b"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-fd4bf14720dcaf8b" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>rwg_modetable(::AbstractString, ::Unitful.Quantity{&lt;:Real, Unitful.dimension(u&quot;Hz&quot;)})</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-5a9578ad1b3f1880"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-5a9578ad1b3f1880" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>rwg_modetable(::Unitful.Quantity{&lt;:Real, Unitful.dimension(u&quot;m&quot;)},           ::Unitful.Quantity{&lt;:Real, Unitful.dimension(u&quot;m&quot;)},           ::Unitful.Quantity{&lt;:Real, Unitful.dimension(u&quot;Hz&quot;)})</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.rwgte10gz" href="#WaveguideModes.rwgte10gz"><code>WaveguideModes.rwgte10gz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rwgte10gz(a, b, f; ϵᵣ, tanδ, σ, Rq) -&gt; (γ, Z)</code></pre><p>Accurately compute γ and Z (prop. constant and wave impedance) of TE10 mode in rectangular guide with rough walls.</p><p><strong>Required Positional Arguments</strong></p><ul><li><code>a</code>,  <code>b</code>: The waveguide x and y dimensions, <code>Unitful</code> quantities with dimensions of length.</li><li><code>f</code>: Frequency, a <code>Unitful</code> quantity with dimensions of inverse time.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>ϵᵣ</code>, <code>tanδ</code>: Dielectric constant and loss tangent, respectively, of material filling the waveguide. Default values are <code>1.0</code> and <code>0.0</code>, respectively.</li><li><code>σ</code>: The bulk conductivity of the waveguide metal walls, a Unitful quantity with the same dimensions as <code>u&quot;S/m&quot;</code>. Default value is <code>Inf*u&quot;S/m&quot;</code>.</li><li><code>Rq</code>: The RMS surface roughness of the waveguide walls, a <code>Unitful</code> quantity with dimension of length. Default value is <code>0.0u&quot;m&quot;</code></li></ul><p><strong>Return Values</strong></p><ul><li><code>γ</code>: Complex propagation constant [neper/m]</li><li><code>Z</code>: Complex wave impedance [Ω]</li></ul><p><strong>References</strong></p><ul><li>[1] Lomakin, Konstantin, Gerald Gold, and Klaus Helmreich. &quot;Analytical waveguide model precisely predicting loss and delay including surface roughness.&quot; IEEE Transactions on Microwave Theory and Techniques 66, no. 6 (2018): 2649-2662.</li><li>[2] Gold, Gerald, and Klaus Helmreich. &quot;A physical surface roughness model and its applications.&quot; IEEE Transactions on Microwave Theory and Techniques 65, no. 10 (2017): 3720-3732.</li><li>[3] Lomakin, Konstantin, Gerald Gold, and Klaus Helmreich. &quot;Transmission line model for rectangular  waveguides accurately incorporating loss effects.&quot; In 2017 IEEE 21st Workshop on Signal and Power  Integrity (SPI), pp. 1-4. IEEE, 2017.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section><section><div><pre><code class="language-julia hljs">rwgte10gz(wgspec, f; kwargs...) -&gt; (γ, Z)</code></pre><p>This method accepts a rectangular waveguide &quot;specification string&quot; instead of a and b dimensions.</p><p><strong>Required Positional Inputs</strong></p><ul><li><code>wgspec::AbstractString</code>: A standard (EIA, RCSC, or IEC) abbreviation for a rectangular waveguide size. Examples include <code>&quot;WR650&quot;</code> (EIA), <code>&quot;WG7&quot;</code> (RCSC), and <code>&quot;R22&quot;</code> (IEC).</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>ϵᵣ</code>, <code>tanδ</code>: Dielectric constant and loss tangent, respectively, of material filling the waveguide. Default values are <code>1.0</code> and <code>0.0</code>, respectively.</li><li><code>σ</code>: The bulk conductivity of the waveguide metal walls, a Unitful quantity with the same dimensions as <code>u&quot;S/m&quot;</code>. Default value is <code>Inf*u&quot;S/m&quot;</code>.</li><li><code>Rq</code>: The RMS surface roughness of the waveguide walls, a <code>Unitful</code> quantity with dimension of length. Default value is <code>0.0u&quot;m&quot;</code></li></ul><p><strong>Return Values</strong></p><ul><li><code>γ</code>: Complex propagation constant [neper/m]</li><li><code>Z</code>: Complex wave impedance [Ω]</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section><section><div><pre><code class="language-julia hljs">rwgte10gz(a::Real, b::Real, f::Real; ϵᵣ::Real=1.0, tanδ::Real=0.0, σ::Real=Inf, Rq::Real=0.0) -&gt; (γ, Z)
rwgte10gz(a::Real, b::Real, f::Real; epsr::Real=1.0, tandel::Real=0.0, sigma::Real=Inf, Rq::Real=0.0) -&gt; (γ, Z)</code></pre><p>This method accepts SI values as pure numbers (without attached units). </p><p><strong>Required Positional Arguments</strong></p><ul><li><code>a</code>,  <code>b</code>: The waveguide x and y dimensions [m].</li><li><code>f</code>: Frequency [Hz]</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>ϵᵣ</code> or <code>epsr</code>: Dielectric constant of material filling the waveguide. Default value is <code>1.0</code>.</li><li><code>tanδ</code> or <code>tandel</code>: Loss tangent of material filling the waveguide. Default value is <code>0.0</code>. </li><li><code>σ</code> or <code>sigma</code>: The bulk conductivity of the waveguide metal walls [S/m]. Default value is <code>Inf</code>.</li><li><code>Rq</code>: The RMS surface roughness of the waveguide walls [m]. Default value is <code>0.0</code>.</li></ul><p><strong>Return Value</strong></p><p>The tuple <code>(γ, Z)</code> where:</p><ul><li><code>γ</code>: Complex propagation constant [neper/m]</li><li><code>Z</code>: Complex wave impedance [Ω]</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><h2 id="Publicly-Exported-Types"><a class="docs-heading-anchor" href="#Publicly-Exported-Types">Publicly Exported Types</a><a id="Publicly-Exported-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Publicly-Exported-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.RWG" href="#WaveguideModes.RWG"><code>WaveguideModes.RWG</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RWG &lt;: HomogeneousMetallicWaveguide</code></pre><p>A struct representing a section of metallic, rectangular waveguide, uniformly filled with dielectric. It is assumed that the (possibly non-smooth) metal walls are either perfectly conducting or form a  &quot;good conductor&quot;, in the sense that the standard perturbational formulas for losses in waveguide walls hold for higher-order modes.  For the dominant TE10 and the TE01 modes, accurate formulas from the recent literature are used. See the docstring for function <code>rwgte10gz</code> for more information.</p><p><strong>Fields</strong></p><ul><li><code>a::Float64</code>: The x-dimension of the waveguide [m].</li><li><code>b::Float64</code>: The y-dimension of the waveguide [m].</li><li><code>l::Float64</code>: The length of the waveguide section (along z) [m].</li><li><code>ϵᵣ::Float64</code>: The dielectric constant for the material filling the guide [unitless].</li><li><code>tanδ::Float64</code>: The loss tangent for the material filling the guide [unitless].</li><li><code>σ::Float54</code>: The bulk conductivity of the waveguide metal walls [S/m].</li><li><code>Rq::Float64</code>: The metal wall RMS surface roughness [m].</li><li><code>modes::Vector{RWGMode}</code>: The modes treated in this guide.  If provided, the list  should be sorted in order of increasing cutoff frequency.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.RWGMode" href="#WaveguideModes.RWGMode"><code>WaveguideModes.RWGMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RWGMode &lt;: HomogeneousMetalPipeMode</code></pre><p>Struct representing an electromagnetic mode of a rectangular waveguide, homogeneously filled with dielectric.</p><p><strong>Fields:</strong></p><ul><li><code>p::TETM</code>: Mode type.</li><li><code>m::Int</code>: Index for modal variation along x direction.</li><li><code>n::Int</code>: Index for modal variation along y direction.</li><li><code>kco::Float64</code>: Cutoff wavenumber [radian/meter].</li><li><code>f::Float64</code>: Frequency [Hz].</li><li><code>γ::ComplexF64</code>: Attenuation constant [neper/meter].</li><li><code>Z::ComplexF64</code>: Modal wave impedance normalized to η₀, the impedance of free space [unitless].</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><h1 id="Non-Exported-API-(Subject-to-Change)"><a class="docs-heading-anchor" href="#Non-Exported-API-(Subject-to-Change)">Non-Exported API (Subject to Change)</a><a id="Non-Exported-API-(Subject-to-Change)-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Exported-API-(Subject-to-Change)" title="Permalink"></a></h1><h2 id="Private-Functions"><a class="docs-heading-anchor" href="#Private-Functions">Private Functions</a><a id="Private-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Private-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.aha_gammas-NTuple{6, Any}" href="#WaveguideModes.aha_gammas-NTuple{6, Any}"><code>WaveguideModes.aha_gammas</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">aha_gammas(a, b, m, n, k, Zsnorm; kwargs...)</code></pre><p>Compute estimates of the complex attenuation constant for a pair of TE and TM rectangular waveguide modes,  by finding the zeros of the 2x2 matrix <code>A&#39; * A</code>, where <code>A</code> is the matrix returned by <code>e0h0mat</code>.</p><p><strong>Positional Arguments</strong></p><ul><li><code>a</code>, <code>b</code>: Waveguide dimensions along x and y, respectively [m].</li><li><code>m</code>, <code>n</code>: Nonnegative integer mode numbers along x and y, respectively, not both zero.</li><li><code>k</code>: The wavenumber in the dielectric medium filling the waveguide.</li><li><code>Zsnorm</code>: The surface impedance of the metal waveguide walls normalized to the intrinsic impedance of the dielectric medium.</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>x01</code>, <code>x02</code>: Real-valued 2-vectors containing initial guesses for the first and second root-finding runs. These are converted into initial guesses for <code>kxa</code> and <code>kyb</code> via the function <code>kxakyb_from_xmn</code>.  They default to <code>SVector(0.0,0.0)</code> and <code>reverse(x1)</code>, respectively, where <code>x1</code> is the first solution.</li><li><code>abstol1</code>, <code>abstol2</code>: Tolerances passed to <code>Nonlinearsolve.solve</code> for the first and second root-finding runs. These default to <code>1e-19</code> and <code>1e-15</code>, respectively.</li></ul><p><strong>Return Value</strong></p><p><code>(; γte, γtm)</code>:  TE and TM complex attenuation constants [Np/m]. If <code>any(iszero, (m,n))</code> then only the TE mode  can exist and <code>γtm</code> will be set to <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.alphaploss-Tuple{Any, Number, Real}" href="#WaveguideModes.alphaploss-Tuple{Any, Number, Real}"><code>WaveguideModes.alphaploss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">alphaploss(params, k, Rsnorm)</code></pre><p>Compute the attenuation constant of a rectangular waveguide using the classical power loss method.</p><p><strong>Input Arguments</strong></p><ul><li><p><code>params</code>: A NamedTuple or other destructurable object containing the following fields:</p><ul><li><code>a</code>, <code>b</code>: waveguide dimensions in x and y directions [m].</li><li><code>m</code>, <code>n</code>, <code>p::TETM</code>: Mode indices and mode type.</li><li><code>kco</code>: Cutoff wavenumber of mode [rad/m].</li></ul></li><li><p><code>k</code>: Wavenumber in the dielectric filling the waveguide.</p></li><li><p><code>Rsnorm</code>: Ratio of surface resistance of the waveguide metal walls to the intrinsic impedance of the  dielectric filling the waveguide.</p><p><strong>Return Value</strong></p></li><li><p><code>α</code>:  For frequencies above cutoff, the attenuation constant [np/m] calculated via the classical  power loss method.  For frequencies below cutoff, zero is returned.</p></li></ul><p><strong>References:</strong></p><ol><li>R. E. Collin, <strong>Field Theory of Guided Waves</strong> 2cd Edition, IEEE Press, 1991, Table 5.2, p. 351.</li><li>J. Uher, J. Bornemann and U. Rosenberg, <strong>Waveguide Components for Antenna Feed Systems: Theory and CAD</strong>, Artech House, 1991, p. 114.</li></ol></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.collin_gamma-Tuple{Real, Real, Integer, Integer, WaveguideModes.TETM, Any, Any}" href="#WaveguideModes.collin_gamma-Tuple{Real, Real, Integer, Integer, WaveguideModes.TETM, Any, Any}"><code>WaveguideModes.collin_gamma</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collin_gamma(a, b, m, n, p, k, Zsnorm)</code></pre><p>Compute variational estimate of the complex attenuation constant for a rectangular waveguide mode,  using the variational method described in the reference.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>, <code>b</code>: Waveguide dimensions along x and y, respectively [m].</li><li><code>m</code>, <code>n</code>: Nonnegative integer mode numbers along x and y, respectively, not both zero, and neither zero if <code>p == TM</code>.</li><li><code>p::TETM</code>: Mode type (TE or TM).</li><li><code>k</code>: The wavenumber in the dielectric medium filling the waveguide.</li><li><code>Zsnorm</code>: The surface impedance of the metal waveguide walls normalized to the intrinsic impedance of the dielectric medium.</li></ul><p><strong>Return Value</strong></p><p><code>γ</code>: A variational estimate of the complex attenuation constant [Np/m] of the specified mode.</p><p><strong>Reference:</strong></p><ul><li>R. E. Collin, <strong>Field Theory of Guided Waves</strong> 2cd Edition, IEEE Press, 1991, pp. 350-354.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.collin_gamma_objective-Tuple{Any, Any}" href="#WaveguideModes.collin_gamma_objective-Tuple{Any, Any}"><code>WaveguideModes.collin_gamma_objective</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collin_gamma_objective(Δγari, parameters)</code></pre><p>Objective function for <code>collin_gamma</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Δγari</code>: A 2-vector containing real and imaginary parts of <code>Δγa</code>. The latter is defined such that the current estimate for <code>γ</code> is obtained as <code>im*β + Δγa / a</code>.  Note that <code>Δγa</code> is unitless, and is also very small for a waveguide with good conductor walls.</li><li><code>parameters</code>: A named tuple consisting of at least the following fields:<ul><li><code>a</code>: Waveguide x dimension [m].</li><li><code>p::TETM</code>: Desired mode type</li><li><code>β₀</code>: Phase constant of the degenerate modes assuming PEC walls [rad/m].</li><li><code>β₀²</code>: The square of <code>β₀</code>.</li><li><code>f11</code>, <code>term11b</code>, <code>A12</code>, <code>A21</code>, <code>term22b</code>: Constants needed to evaluate the matrix elements defined in Eq. (66) on page 353 of the reference. These have all been multiplied by the waveguide dimension <code>a</code> to render them unitless.</li></ul></li></ul><p><strong>Return Value</strong></p><ul><li>A named tuple with the following fields<ul><li><code>objective</code>: The absolute value of the determinant of <code>A</code>.</li><li><code>Δγa</code>: <code>complex(Δγari[1], Δγari[2])</code>.</li><li><code>γ</code>: The complex attenuation constant obtained from the given inputs [1/m].</li><li><code>A</code>: The 2x2 matrix defined in Collin, <strong>Field Theory of Guided Waves</strong> Eq. (66) on page 353. The matrix has been multiplied by the waveguide dimension <code>a</code> to render it unitless.</li><li><code>determ</code>:  The determinant of <code>A</code>.</li></ul></li></ul><p><strong>Reference:</strong></p><ul><li>R. E. Collin, <strong>Field Theory of Guided Waves</strong> 2cd Edition, IEEE Press, 1991, page 353.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.collin_gammas-Tuple{Real, Real, Integer, Integer, Any, Any}" href="#WaveguideModes.collin_gammas-Tuple{Real, Real, Integer, Integer, Any, Any}"><code>WaveguideModes.collin_gammas</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collin_gammas(a, b, m, n, k, Zsnorm)</code></pre><p>Compute variational estimate of the complex attenuation constant for a rectangular waveguide mode,  using the variational method described in the reference.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>, <code>b</code>: Waveguide dimensions along x and y, respectively [m].</li><li><code>m</code>, <code>n</code>: Nonnegative integer mode numbers along x and y, respectively, not both zero, and neither zero if <code>p == TM</code>.</li><li><code>k</code>: The wavenumber in the dielectric medium filling the waveguide.</li><li><code>Zsnorm</code>: The surface impedance of the metal waveguide walls normalized to the intrinsic impedance of the dielectric medium.</li></ul><p><strong>Return Value</strong></p><p><code>(; γte, γtm)</code>:  TE and TM complex attenuation constants [Np/m].</p><p><strong>Reference:</strong></p><ul><li>R. E. Collin, <strong>Field Theory of Guided Waves</strong> 2cd Edition, IEEE Press, 1991, pp. 350-354.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.collin_matrix_params-Tuple{Real, Real, Integer, Integer, Any, Any}" href="#WaveguideModes.collin_matrix_params-Tuple{Real, Real, Integer, Integer, Any, Any}"><code>WaveguideModes.collin_matrix_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collin_matrix_params(a, b, m, n, k, Zsnorm)</code></pre><p>Compute parameters needed to efficiently form the coefficient matrix used in the Collin variational method for attenuation of TE/TM degenerate modes in rectangular waveguide.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>, <code>b</code>: Waveguide dimensions along x and y, respectively [m].</li><li><code>m</code>, <code>n</code>: Nonnegative integer mode numbers along x and y, respectively, not both zero.</li><li><code>k</code>: The wavenumber in the dielectric medium filling the waveguide.</li><li><code>Zsnorm</code>: The surface impedance of the metal waveguide walls normalized to the intrinsic impedance of the dielectric medium.</li></ul><p><strong>Return Value</strong></p><ul><li><code>parameters</code>: A named tuple with the following fields:<ul><li><code>a</code>: The waveguide x dimension [m].</li><li><code>β₀</code>: The waveguide phase constant assuming perfectly conducting walls</li><li><code>β₀²</code>: The square of <code>β₀</code>.</li><li><code>f11</code>, <code>term11b</code>, <code>term22b</code>:  Constants occuring in the equations for the matrix coefficients.</li><li><code>A12</code>, <code>A21</code>: The off-diagonal matrix coefficients.</li></ul></li></ul><p><strong>Reference:</strong></p><ul><li>R. E. Collin, <strong>Field Theory of Guided Waves</strong> 2cd Edition, IEEE Press, 1991, pp. 350-354.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.collinmatrix-Tuple{Any, Any}" href="#WaveguideModes.collinmatrix-Tuple{Any, Any}"><code>WaveguideModes.collinmatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collinmatrix(γ, parameters)</code></pre><p>Compute the 2x2 matrix from Eq. (66) of the reference (after each row is multiplied by <code>a</code> to render the matrix unit-free).</p><p><strong>Arguments</strong></p><ul><li><code>γ</code>: The complex attenuation constant [Np/m] from which the matrix is to be computed.</li><li><code>parameters</code>: A named tuple consisting of at least the following fields:<ul><li><code>β₀²</code>: The square of the phase constant for the waveguide with PEC walls [1/m].</li><li><code>f11</code>, <code>term11b</code>, <code>A12</code>, <code>A21</code>, <code>term22b</code>: Constants needed to evaluate the matrix elements defined in Collin Eq. (66) on page 353.  These have all been multiplied by  waveguide dimension <code>a</code> to render them unitless.</li></ul></li></ul><p><strong>Return Value</strong></p><ul><li><code>detabs2</code>:  The magnitude squared of the determinant of the matrix equation in Eq. (66),  after each row has been multiplied by <code>a</code> to make the matrix entries unitless.</li></ul><p><strong>Reference:</strong></p><ul><li>R. E. Collin, <strong>Field Theory of Guided Waves</strong> 2cd Edition, IEEE Press, 1991, pp. 353.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.compute_As_kxakybs-Tuple{Real, Any, Any}" href="#WaveguideModes.compute_As_kxakybs-Tuple{Real, Any, Any}"><code>WaveguideModes.compute_As_kxakybs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_As_kxakybs(FGHz, rwg, mode_params; iterate=false)

Compute dispersion matrices for a rectangular waveguide with lossy walls using 4 choices of (δx, δy)</code></pre><p><strong>Input Arguments</strong></p><ul><li><code>FGHz</code>: The desired analysis frequency in GHz.</li><li><code>rwg</code>: An <code>RWG</code> or other struct or named tuple with at least fields <code>a</code>, <code>b</code>, <code>σ</code>, and <code>Rq</code> set.</li><li><code>mode_params</code>: Named tuple or struct with fields <code>m::Integer</code>, <code>n::Integer</code>, <code>p::TETM</code> defining the desired mode.</li><li><code>iterate</code>: If <code>false</code> (default), then the <code>δx</code> and <code>δy</code> values computed from [1] are used directly to compute kx and ky and thus γ. If true, then these values are used as starting values in a root-finding algorithm implementing the numerical search described in [2].</li></ul><p><strong>Return value</strong></p><p><code>(As, kxakybs)</code>, where</p><ul><li><p><code>As</code>: A 4-vector containing four complex matrices of size (4,2) containing the coefficients of E0 and η*H0 in the modal  dispersion relation.  <code>As[i]</code> contains the matrix obtained by choosing (δx, δy) to be</p><ul><li><code>i==1</code>: (δx1, δy1)</li><li><code>i==2</code>: (δx2, δy1)</li><li><code>i==3</code>: (δx1, δy2)</li><li><code>i==4</code>: (δx2, δy2)</li></ul></li><li><p><code>kxakybs</code>: A 4-vector containing tuples <code>(kx*a, ky*b)</code> computed for the same four cases as <code>As</code>.</p></li></ul><p><strong>References</strong></p><ul><li>[1] Yeap, Kim Ho, et al. &quot;Attenuation in circular and rectangular waveguides,&quot; <strong>Electromagnetics</strong> 37.3 (2017): 171-184.</li><li>[2] Yeap, Kim Ho, et al. &quot;Attenuation in rectangular waveguides with finite conductivity walls.&quot; Radioengineering 20.2 (2011).</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.cwgkcoa-Tuple{WaveguideModes.TETM, Integer, Integer}" href="#WaveguideModes.cwgkcoa-Tuple{WaveguideModes.TETM, Integer, Integer}"><code>WaveguideModes.cwgkcoa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cwgkcoa(p::TETM, m::Integer, n::Integer)</code></pre><p>Compute the the product of cutoff wavenumber times radius for a circular waveguide.</p><p><strong>Required Positional Arguments</strong></p><ul><li><code>p</code>: Mode type (<code>TE</code> or <code>TM</code>).</li><li><code>m</code>: Mode number for azimuthal variation. Must be nonnegative.</li><li><code>n</code>: Mode number for radial variation. Must be positive.</li></ul><p><strong>Return Value</strong></p><ul><li><code>kcoa</code>: The cutoff wavenumber of the mode times the waveguide radius.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.cwgkza_abe-Tuple{WaveguideModes.TETM, Integer, Float64, ComplexF64, ComplexF64}" href="#WaveguideModes.cwgkza_abe-Tuple{WaveguideModes.TETM, Integer, Float64, ComplexF64, ComplexF64}"><code>WaveguideModes.cwgkza_abe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cwgkza_abe(p::TETM, m, umn, ka, Zsn)</code></pre><p>Compute product of z-directed complex wavenumber kz and waveguide radius a for a circular waveguide.</p><p><strong>Arguments</strong></p><ul><li><code>p::TETM</code>: Mode type (<code>TE</code> or <code>TM</code>).</li><li><code>m::Integer</code>: Mode index for variation in ϕ direction.</li><li><code>umn::Float64</code>: Equal to kco * a, where kco is the cutoff wavenumber for the mode of interest. (For circular guides this is a zero of the Bessel function J_m or a zero of its derivative).</li><li><code>ka::ComplexF64</code>: Product of wavenumber (for the dielectric filling the guide) times the waveguide radius.</li><li><code>Zsn::ComplexF64</code>: The ratio of the metal wall surface impedance to the intrinsic impedance of the dielectric material filling the waveguide.</li></ul><p><strong>Return Value</strong></p><ul><li>&#39;kza::Complex64&#39;: Product of the waveguide radius with the z-directed wavenumber [1/m] including both propagation (imaginary part) and attenuation (real part).</li></ul><p><strong>Reference</strong></p><p>T. Abe and Y. Yamaguchi, &quot;Propagation Constant Below Cutoff Frequency in a Circular Waveguide with Conducting Medium&quot;, IEEE Trans. MTT, Vol. MTT-29, no. 7, July 1981, pp. 707-712.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.cwgkza_ploss-Tuple{WaveguideModes.TETM, Integer, Float64, ComplexF64, ComplexF64}" href="#WaveguideModes.cwgkza_ploss-Tuple{WaveguideModes.TETM, Integer, Float64, ComplexF64, ComplexF64}"><code>WaveguideModes.cwgkza_ploss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cwgkza_ploss(p::TETM, m, umn, ka, Zsn)</code></pre><p>Compute product of z-directed complex wavenumber kz and waveguide radius a for a circular waveguide.  Estimate the attenuation for modes above cutoff using the power loss method.</p><p><strong>Arguments</strong></p><ul><li><code>p::TETM</code>: Mode type (<code>TE</code> or <code>TM</code>).</li><li><code>m::Integer</code>: Mode index for variation in ϕ direction.</li><li><code>umn::Float64</code>: Equal to kco * a, where kco is the cutoff wavenumber for the mode of interest. (For circular guides this is a zero of the Bessel function J_m or a zero of its derivative).</li><li><code>ka::ComplexF64</code>: Product of wavenumber (for the dielectric filling the guide) times the waveguide radius.</li><li><code>Zsn::ComplexF64</code>: The ratio of the metal wall surface impedance to the intrinsic impedance of the dielectric material filling the waveguide.</li></ul><p><strong>Return Value</strong></p><ul><li>&#39;kza::Complex64&#39;: Product of the waveguide radius with the z-directed wavenumber [1/m] including both propagation (imaginary part) and attenuation (real part).</li></ul><p><strong>Reference</strong></p><p>R. Collin, <strong>Field Theory of Guided Waves, 2cd Edition</strong>, Table 5.5.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.cwgkza_yeap-Tuple{WaveguideModes.TETM, Integer, Float64, ComplexF64, ComplexF64}" href="#WaveguideModes.cwgkza_yeap-Tuple{WaveguideModes.TETM, Integer, Float64, ComplexF64, ComplexF64}"><code>WaveguideModes.cwgkza_yeap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cwgkza_yeap(p::TETM, m, umn, ka, Zsn)</code></pre><p>Compute product of z-directed complex wavenumber kz and waveguide radius a for a circular waveguide.</p><p><strong>Arguments</strong></p><ul><li><code>p::TETM</code>: Mode type (<code>TE</code> or <code>TM</code>).</li><li><code>m::Integer</code>: Mode index for variation in ϕ direction.</li><li><code>umn::Float64</code>: Equal to kco * a, where kco is the cutoff wavenumber for the mode of interest. (For circular guides this is a zero of the Bessel function J_m or a zero of its derivative).</li><li><code>ka::ComplexF64</code>: Product of wavenumber (for the dielectric filling the guide) times the waveguide radius.</li><li><code>Zsn::ComplexF64</code>: The ratio of the metal wall surface impedance to the intrinsic impedance of the dielectric material filling the waveguide.</li></ul><p><strong>Return Value</strong></p><ul><li>&#39;kza::Complex64&#39;: Product of the waveguide radius with the z-directed wavenumber [1/m] including both propagation (imaginary part) and attenuation (real part).</li></ul><p><strong>Reference</strong></p><p>K. H. Yeap et al: &quot;Attenuation in Circular and Rectangular Waveguides&quot;, Electromagnetics, Vol. 37, No. 3, 2017, pp. 171-184</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.e0h0_2x2_det-Tuple{Any, Any, Any}" href="#WaveguideModes.e0h0_2x2_det-Tuple{Any, Any, Any}"><code>WaveguideModes.e0h0_2x2_det</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">e0h0_2x2_det(kxa, kyb, params) -&gt; (d, AHA)</code></pre><p>Compute the determinant <code>d</code> of the 2x2 matrix <code>AHA = A&#39;*A</code> where <code>A</code> is returned from <code>e0h0mat</code>.</p><p><strong>Input Arguments</strong></p><ul><li><code>kxa</code>, <code>kyb</code>: The (unitless) product of proposed x and y modal wavenumbers times the x and y dimensions of the waveguide, resp.</li><li><code>params</code>: A struct or named tuple containing the following parameters of the waveguide problem:<ul><li><code>m</code>, <code>n</code>: Mode numbers in the x and y directions, resp.</li><li><code>a</code>, <code>b</code>: Waveguide x and y dimensions, resp. [m]</li><li><code>k</code>: Wavenumber [radians/m] in the dielectric filling the waveguide.</li><li><code>ηwn</code>: The wall surface impedance normalized to the intrinsic impedance of the dielectric filling the waveguide.</li></ul></li></ul><p><strong>Return Value</strong></p><ul><li><code>(d, AHA)</code> where<ul><li><code>d</code> is the real-valued determinant of the hermitian matrix <code>AHA</code>, and</li><li><code>AHA</code>: is an hermitian <code>SMatrix</code> of dimensions 2×2 computed as <code>A&#39; * A</code> where <code>A</code> is the matrix returned from <code>e0h0mat</code>.  Note that the eigenvalues of <code>AHA</code> are the squares of the singular values of <code>A</code>.  Hence searching for a zero determinant of <code>AHA</code> is equivalent to searching for a zero singular value of <code>A</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.e0h0mat-Tuple{Any, Any, Any}" href="#WaveguideModes.e0h0mat-Tuple{Any, Any, Any}"><code>WaveguideModes.e0h0mat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">e0h0mat(kxa, kyb, params)</code></pre><p>Compute the dispersion matrix <code>A</code> whose null space defines the possible z-component field coefficients.</p><p><strong>Input Arguments</strong></p><ul><li><code>kxa</code>, <code>kyb</code>: The (unitless) product of proposed x and y modal wavenumbers times the x and y dimensions of the waveguide, resp.</li><li><code>params</code>: A struct or named tuple containing the following parameters of the waveguide problem:<ul><li><code>m</code>, <code>n</code>: Mode numbers in the x and y directions, resp.</li><li><code>a</code>, <code>b</code>: Waveguide x and y dimensions, resp. [m]</li><li><code>k</code>: Wavenumber [radians/m] in the dielectric filling the waveguide.</li><li><code>ηwn</code>: The wall surface impedance normalized to the intrinsic impedance of the dielectric filling the waveguide.</li></ul></li></ul><p><strong>Return Value</strong></p><ul><li><code>A</code>: <code>SMatrix</code> of dimensions 4×2 computed using the provided inputs, whose nullspace spans the possible modal vectors <code>[E₀, η*H₀]</code>.  Here <code>E₀</code> is the coefficient of the z-component of electric field, <code>H₀</code> is the coefficient of the z-component of magnetic field, and η is the intrinsic impedance of the dielectric filling the waveguide.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.kxakyb_from_xmn-Tuple{AbstractVector{&lt;:Real}, Integer, Integer}" href="#WaveguideModes.kxakyb_from_xmn-Tuple{AbstractVector{&lt;:Real}, Integer, Integer}"><code>WaveguideModes.kxakyb_from_xmn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kxakyb_from_xmn(x, m, n) -&gt; (kxa, kyb)</code></pre><p>Compute <code>kx*a</code> and <code>ky*b</code> from the two-vector <code>x</code> and the nonnegative integers <code>m</code> and <code>n</code>.</p><p>This parameterization assumes that <code>kxa</code> and <code>kyb</code> are both located on lines in the complex plane  passing through the origin and with slopes equal to -1.</p><p><strong>Input Arguments</strong></p><ul><li><code>x</code>: A real-valued 2-vector consisting of <code>[Δkxa, Δkyb]</code>. These are used to compute the increments in <code>kx*a</code> and <code>ky*b</code> from their loss-free values <code>kxa0, kyb0 = m*π, n*π</code> via <code>(Δkxa, Δkyb) .* complex(-1,1)</code>.</li><li><code>m</code>, <code>n</code>: Mode indices in the x and y directions, respectively.  Values should be nonnegative and not both zero.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.mysqrt-Tuple{Any}" href="#WaveguideModes.mysqrt-Tuple{Any}"><code>WaveguideModes.mysqrt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mysqrt(x)</code></pre><p>Same as <code>sqrt</code> unless <code>sqrt(x)</code> is pure negative imaginary in which case it returns <code>-sqrt(x)</code> (i.e., positive pure imaginary).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.nlsolvedkxadkyb-Tuple{AbstractVector, Any}" href="#WaveguideModes.nlsolvedkxadkyb-Tuple{AbstractVector, Any}"><code>WaveguideModes.nlsolvedkxadkyb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nlsolvedkxadkyb(Δs, params) -&gt; residual::SVector{4, Float64}</code></pre><p>Function defining a NonLinearProblem whose solution provides rigorously correct kx and ky values for a rectangular waveguide.</p><p><strong>Positional Arguments</strong></p><ul><li><code>Δs</code>: A 4-vector containing the unitless values <code>[real(Δkxa), imag(Δkxa), real(Δkyb), imag(Δkyb)].  Here</code>Δkxa<code>is the departure of</code>kx<code>from its nominal value (for PEC walls) of</code>m<em>π/a<code>.  Similarly,</code>Δkyb<code>is the departure of</code>ky<code>from its nominal value of</code>n</em>π/b<code>.  The entries in</code>Δs` are to be adjusted to produce a zero return vector.</li><li><code>params</code>:  A named tuple containing the fixed parameters of the waveguide problem.  These are<ul><li><code>m</code> and <code>n</code>: Mode indices in the x and y directions, respectively.</li><li><code>k</code>: The (complex) wavenumber in the dielectric filling the waveguide [radians/m].</li><li><code>a</code> and  <code>b</code>:  The waveguide (inner) dimensions in the x and y directions, respectively [m].</li><li><code>ηwn</code>: Waveguide wall surface impedance normalized to the intrinsic impedance of the dielectric filling the waveguide.</li></ul></li></ul><p><strong>Return Value</strong></p><ul><li><code>residual</code>: A static 4-vector containing the real and imaginary parts of the two expressions that must be zeroed for a valid  solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.nlsolvekxakyb-Tuple{AbstractVector, Any}" href="#WaveguideModes.nlsolvekxakyb-Tuple{AbstractVector, Any}"><code>WaveguideModes.nlsolvekxakyb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nlsolvekxakyb(rikakbs, params) -&gt; residual::SVector{4, Float64}</code></pre><p>Function defining a NonLinearProblem whose zero solves the determinantal equations for the kx and ky values of a rectangular waveguide.</p><p><strong>Positional Arguments</strong></p><ul><li><code>rikakbs</code>: A 4-vector containing the unitless values <code>[real(kxa), imag(kxa), real(kyb), imag(kyb)].  Here</code>kxa<code>is the product of</code>kx<code>and</code>a<code>(the waveguide x dimension) Similarly,</code>kyb<code>is the product of</code>ky<code>and</code>b<code>(the waveguide y dimension). The entries in</code>rikakbs` are to be adjusted to produce a zero return vector.</li><li><code>params</code>:  A named tuple containing the fixed parameters of the waveguide problem.  These are<ul><li><code>m</code> and <code>n</code>: Mode indices in the x and y directions, respectively.</li><li><code>k</code>: The (complex) wavenumber in the dielectric filling the waveguide [radians/m].</li><li><code>a</code> and  <code>b</code>:  The waveguide (inner) dimensions in the x and y directions, respectively [m].</li><li><code>ηwn</code>: Waveguide wall surface impedance normalized to the intrinsic impedance of the dielectric filling the waveguide.</li></ul></li></ul><p><strong>Return Value</strong></p><ul><li><code>residual</code>: A static 4-vector containing the real and imaginary parts of the two expressions that must be zeroed for a valid  solution.</li></ul><p><strong>Reference:</strong></p><ul><li>[1] Yeap, Kim Ho, et al. &quot;Attenuation in circular and rectangular waveguides.&quot; <strong>Electromagnetics</strong> 37.3 (2017): 171-184.  See Eqs. (6a) and (6b).</li><li>[2] P. Simon, &quot;Notes on Attenuation in Circular and Rectangular Waveguides&quot;, Eqs (7a) and (7b).</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.objective_e0h0_2x2-Tuple{Any, Any}" href="#WaveguideModes.objective_e0h0_2x2-Tuple{Any, Any}"><code>WaveguideModes.objective_e0h0_2x2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">objective_e0h0_2x2(x, params) -&gt; d::Real</code></pre><p>Objective function returning the determinant <code>d</code> of <code>A&#39;*A</code> where <code>A</code> is the 4x2 matrix returned from <code>e0h0mat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A real-valued 2-vector consisting of <code>[Δkxa, Δkyb]</code>. These are used to compute the increments in <code>kx*a</code> and <code>ky*b</code> from their loss-free values <code>kxa0, kyb0 = m*π, n*π</code> via <code>(Δkxa, Δkyb) .* complex(-1,1)</code>.</li><li><code>params</code>: A struct or named tuple containing the following parameters of the waveguide problem:<ul><li><code>m</code>, <code>n</code>: Mode numbers in the x and y directions, resp.</li><li><code>a</code>, <code>b</code>: Waveguide x and y dimensions, resp. [m]</li><li><code>k</code>: Wavenumber [radians/m] in the dielectric filling the waveguide.</li><li><code>ηwn</code>: The wall surface impedance normalized to the intrinsic impedance of the dielectric filling the waveguide.</li></ul></li></ul><p><strong>Return Value</strong></p><pre><code class="language-julia hljs">`@SVector [d]`: The determinant of the hermitian 2x2 matrix `A&#39; * A` returned in a 1-element `SVector`,
as is appropriate for use with NonlinearSolve.</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.rwg_δxδys-Tuple{Real, WaveguideModes.TETM, Any}" href="#WaveguideModes.rwg_δxδys-Tuple{Real, WaveguideModes.TETM, Any}"><code>WaveguideModes.rwg_δxδys</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rwg_δxδys(f, p, params)

Compute the 4 possible choices of (δx, δy) for a rectangular waveguide as defined in Eqs. (14) of the reference.</code></pre><p><strong>Input Arguments</strong></p><ul><li><code>f::Real</code>: The desired analysis frequency [Hz]</li><li><code>p::TETM</code>: Mode type (<code>TE</code> or <code>TM</code>)</li><li><code>params</code>: Named tuple or struct with fields:<ul><li><code>m</code> and <code>n</code>: Mode indices in the x and y directions, respectively.</li><li><code>k</code>: The (complex) wavenumber in the dielectric filling the waveguide [radians/m].</li><li><code>a</code> and  <code>b</code>:  The waveguide (inner) dimensions in the x and y directions, respectively [m].</li><li><code>ηwn</code>: Waveguide wall surface impedance normalized to the intrinsic impedance of the dielectric filling the waveguide.</li></ul></li></ul><p><strong>Return value</strong></p><ul><li><code>δxδys</code>: A length-4 tuple containing <code>((δx1, δy1), (δx2, δy1), (δx1, δy2), (δx2, δy2))</code> where the entries are as defined in Eqs. (14) of the reference. Here, a trailing &quot;1&quot; (&quot;2&quot;) on the variable names means selection of the plus (minus) sign in the corresponding equation.</li></ul><p><strong>References</strong></p><ul><li>[1] Yeap, Kim Ho, et al. &quot;Attenuation in circular and rectangular waveguides,&quot; <strong>Electromagnetics</strong> 37.3 (2017): 171-184.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.rwggz_yeap-Tuple{WaveguideModes.TETM, Int64, Int64, Real, Real, Real}" href="#WaveguideModes.rwggz_yeap-Tuple{WaveguideModes.TETM, Int64, Int64, Real, Real, Real}"><code>WaveguideModes.rwggz_yeap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rwggz_yeap(p, m, n, a, b, f; ϵᵣ = 1.0, tanδ = 0.0, σ = Inf, Rq = 0.0, iδ = 0) -&gt; (γ, Z)
rwggz_yeap(p, m, n, a, b, f; epsr = 1.0, tandel = 0.0, sigma = Inf, Rq = 0.0, iδ = 0) -&gt; (γ, Z)</code></pre><p>Compute γ and Z (prop. constant and wave impedance) of a mode in rectangular guide with rough walls using the method of Yeap et al. [1]. </p><p>This method accepts SI values as pure numbers (without attached units). </p><p><strong>Required Positional Arguments</strong></p><ul><li><code>p::TETM</code>: The mode type.</li><li><code>m::Int</code>, <code>n::Int</code>: Mode indices in the x and y directions, resp.</li><li><code>a::Real</code>,  <code>b::Real</code>: The waveguide x and y dimensions [m].</li><li><code>f</code>: Frequency [Hz].</li></ul><p><strong>Optional Keyword Arguments</strong></p><ul><li><code>ϵᵣ</code> or <code>epsr</code>: Dielectric constant of material filling the waveguide. Default value is <code>1.0</code>.</li><li><code>tanδ</code> or <code>tandel</code>: Loss tangent of material filling the waveguide. Default value is <code>0.0</code>. </li><li><code>σ</code> or <code>sigma</code>: The bulk conductivity of the waveguide metal walls [S/m]. Default value is <code>Inf</code>.</li><li><code>Rq</code>: The RMS surface roughness of the waveguide walls [m]. Default value is <code>0.0</code>.</li><li><code>iδ</code>:  An integer in the range 0:4 denoting which values of <code>δx</code> and <code>δy</code> (as defined in [1]) to use as starting values in the rootfinding procedure.  A value of zero means to start both values equal to zero.  The other values mean that <code>(δx, δy)</code> will be selected as<ul><li><code>iδ==1</code>: (δx1, δy1)</li><li><code>iδ==2</code>: (δx2, δy1)</li><li><code>iδ==3</code>: (δx1, δy2)</li><li><code>iδ==4</code>: (δx2, δy2)</li></ul>Here, the trailing &quot;1&quot; or &quot;2&quot; on the δs indicates selection of the positive or negative sign, respecively, in the  solutions of the quadratic equations as given in Equations (14a) and (14b) of reference [1].</li></ul><p><strong>Return Value</strong></p><p>The tuple <code>(γ, Z)</code> where:</p><ul><li><code>γ</code>: Complex propagation constant [neper/m]</li><li><code>Z</code>: Complex wave impedance [Ω]</li></ul><p><strong>References:</strong></p><ul><li>[1] Yeap, Kim Ho et al., &quot;Attenuation in circular and rectangular waveguides,&quot;  <strong>Electromagnetics</strong> 37, no. 3 (2017): pp. 171-184.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.rwgkco-Tuple{Real, Real, Integer, Integer}" href="#WaveguideModes.rwgkco-Tuple{Real, Real, Integer, Integer}"><code>WaveguideModes.rwgkco</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rwgkco(a, b, m, n)</code></pre><p>Compute the cutoff frequency for a rectangular waveguide.</p><p><strong>Input Variables</strong></p><ul><li><code>a</code>, <code>b</code>: The dimensions of the waveguide in the x and y directions, respectively.</li><li><code>m</code>, <code>n</code>: Mode indices in the x and y directions, respectively.</li></ul><p><strong>Return value:</strong></p><p><code>kco</code>: Cutoff wavenumber in inverse units of <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.update-Tuple{WaveguideModes.HomogeneousMetalPipeMode}" href="#WaveguideModes.update-Tuple{WaveguideModes.HomogeneousMetalPipeMode}"><code>WaveguideModes.update</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update(mode::HomogeneousMetalPipeMode; f::Real, γ::Complex, Z::Complex) -&gt; mode</code></pre><p>Create a copy of an existing mode with updated frequency-dependent fields and return the updated mode.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.zerosolve2x2-Tuple{Any, Any}" href="#WaveguideModes.zerosolve2x2-Tuple{Any, Any}"><code>WaveguideModes.zerosolve2x2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zerosolve2x2(x0, params; abstol = 1e-19, reltol = 1e-15) -&gt; sol</code></pre><p>Locate the zero of the 2x2 hermitian matrix <code>A&#39;* A</code> where <code>A</code> is the matrix returned by <code>e0h0mat</code>.</p><p><strong>Input Arguments</strong></p><ul><li><code>x0</code>: A real-valued 2-vector containing the initial guess for the root-finding algorithm. It consists of <code>[Δkxa, Δkyb]</code>. These are used to compute the increments in <code>kx*a</code> and <code>ky*b</code> from their loss-free values <code>kxa0, kyb0 = m*π, n*π</code> via <code>(Δkxa, Δkyb) .* complex(-1,1)</code>.</li><li><code>params</code>: A struct or named tuple containing the following parameters of the waveguide problem:<ul><li><code>m</code>, <code>n</code>: Mode numbers in the x and y directions, resp.</li><li><code>a</code>, <code>b</code>: Waveguide x and y dimensions, resp. [m]</li><li><code>k</code>: Wavenumber [radians/m] in the dielectric filling the waveguide.</li><li><code>ηwn</code>: The wall surface impedance normalized to the intrinsic impedance of the dielectric filling the waveguide.</li></ul></li></ul><p><strong>Return Value:</strong></p><ul><li><code>sol</code>: The solution object returned by <code>NonlinearSolve.solve</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><h2 id="Private-Types"><a class="docs-heading-anchor" href="#Private-Types">Private Types</a><a id="Private-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Private-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.HomogeneousMetalPipeMode" href="#WaveguideModes.HomogeneousMetalPipeMode"><code>WaveguideModes.HomogeneousMetalPipeMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type HomogeneousMetalPipeMode &lt;: MetalPipeMode end</code></pre><p>Electromagnetic mode supported by homogeneously filled metal pipes.  Concrete subtypes should contain at least the following fields:</p><ul><li><code>p::TETM</code>: Mode classification (TE or TM).</li><li><code>f::Float64</code>: Frequency [Hz].</li><li><code>γ::ComplexF64</code>: Frequency-dependent attenuation constant [np/m].</li><li><code>Z::ComplexF64</code>: Frequency-dependent wave impedance [Ω].</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.MetalPipeMode" href="#WaveguideModes.MetalPipeMode"><code>WaveguideModes.MetalPipeMode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type MetalPipeMode &lt;: Mode end</code></pre><p>Electromagnetic mode supported by metal pipes, possibly filled with inhomogeneous dielectric.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.Mode" href="#WaveguideModes.Mode"><code>WaveguideModes.Mode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type Mode end</code></pre><p>Arbitrary electromagnetic mode.  Should contain the following fields:</p><ul><li><code>γ::ComplexF64</code>: Attenuation constant in z direction [np/m]</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="WaveguideModes.ModeDataTable" href="#WaveguideModes.ModeDataTable"><code>WaveguideModes.ModeDataTable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModeDataTable &lt;: Any</code></pre><p>A struct containing data to be displayed for a few modes of a waveguide</p><p><strong>Fields</strong></p><ul><li><code>title</code>: A <code>String</code> containing the table title.</li><li><code>modedata</code>: An array of size <code>(nrows,ncols)</code> containing the modal data to be output. </li><li><code>coltitles</code>: A vector of <code>ncols</code> strings containing the titles for each column.</li><li><code>colunits</code>:  A vector of <code>ncols</code> strings containing the units used for each column.</li><li><code>col_fmts</code>: A <code>Vector{String}</code> of length <code>ncols</code> containing the <code>@sprinf</code> columnar formats for the numeric entries in the table.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/simonp0420/WaveguideModes.jl.git">source</a></section></article><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 13 November 2025 23:12">Thursday 13 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
